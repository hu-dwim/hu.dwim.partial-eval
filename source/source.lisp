;;; -*- mode: Lisp; Syntax: Common-Lisp; -*-
;;;
;;; Copyright (c) 2009 by the authors.
;;;
;;; See LICENCE for details.

(in-package :hu.dwim.partial-eval)

;;;;;;
;;; Source provider

(def (special-variable e) *sources* (make-hash-table :test #'equal))

(def (function e) read-source (file-name)
  ;; NOTE: all this hassle is to workaround SBCL's bootstrapping package names
  (bind ((original-find-package (fdefinition 'find-package)))
    (unwind-protect
         (progn
           (handler-bind ((package-error (lambda (e)
                                           (continue e))))
             (setf (fdefinition 'find-package) (lambda (designator)
                                                 (if (stringp designator)
                                                     (funcall original-find-package (substitute #\- #\! designator))
                                                     (funcall original-find-package designator)))))
           (setf (gethash file-name *sources*)
                 (with-open-file (src file-name)
                   (iter (for form = (ignore-errors (read src #f :eof)))
                         (until (eq form :eof))
                         (collect form)))))
      (handler-bind ((package-error (lambda (e)
                                      (continue e))))
        (setf (fdefinition 'find-package) original-find-package)))))

(def (function e) find-function-source (function-name)
  (iter (for (file-name source) :in-hashtable *sources*)
        (iter (for form :in source)
              (when (listp form)
                (bind ((first-form (first form))
                       (second-form (second form)))
                  (when (and (eq 'defun first-form)
                             (eq function-name second-form))
                    (return-from find-function-source form)))))))

(def (function e) make-function-lambda-form (function-name)
  (awhen (find-function-source function-name)
    `(lambda ,@(cddr it))))

;; TODO: use the one in alexandria
(def function split-function-lambda-list (lambda-list)
  (iter (for argument-cell :on lambda-list)
        (for argument = (car argument-cell))
        (when (member argument lambda-list-keywords :test #'eq)
          (return (values arguments argument-cell )))
        (collect argument :into arguments)
        (finally (return (values arguments nil)))))

(def function make-generic-method-lambda-form (method)
  (bind (((:values required-arguments other-arguments?) (split-function-lambda-list (sb-pcl:method-lambda-list method)))
         (source (slot-value method 'sb-pcl::source))
         (namestring (slot-value source 'namestring))
         (toplevel-form-number (slot-value source 'sb-c::toplevel-form-number))
         (pathname (make-pathname :device nil :defaults (translate-logical-pathname namestring)))
         (source (gethash pathname *sources*)))
    (iter (with index = 0)
          (for form :in source)
          (when (listp form)
            (when (= index toplevel-form-number)
              (return (with-unique-names (arguments methods)
                        `(lambda (,arguments ,methods)
                           (bind ((,(append required-arguments other-arguments?) ,arguments))
                             ,@(nthcdr (1+ (position-if #'consp form)) form))))))
            (incf index))
          (finally (error "Cannot find source for ~A" method)))))

(def function make-generic-function-discriminating-form (gf arguments-list)
  (bind (((:values required-arguments other-arguments?) (split-function-lambda-list (sb-mop:generic-function-lambda-list gf)))
         (sorted-methods (sb-pcl::sort-applicable-methods
                          (sb-pcl::compute-precedence (sb-mop:generic-function-lambda-list gf)
                                                      (length required-arguments)
                                                      (sb-mop:generic-function-argument-precedence-order gf))
                          (copy-list (sb-mop:generic-function-methods gf))
                          (make-list (length required-arguments) :initial-element t)))
         (methods-info (mapcar (lambda (method)
                                 (list method (gensym "METHOD")))
                               sorted-methods))
         (counter 0)
         (effective-methods-table (make-hash-table))
         (compiled-net (sb-pcl::generate-discrimination-net-internal
                        gf sorted-methods nil
                        (lambda (methods known-types)
                          (declare (ignore known-types))
                          (when methods
                            (bind ((id (incf counter))
                                   (method (first methods)))
                              (setf (gethash method effective-methods-table) id)))
                          `(sb-pcl::methods ,methods))
                        (lambda (position type true-value false-value)
                          (bind ((arg (elt required-arguments position)))
                            (if (eq (car type) 'eql)
                                (bind ((false-case? (and (consp false-value)
                                                         (or (eq (car false-value)
                                                                 'sb-pcl::scase)
                                                             (eq (car false-value)
                                                                 'sb-pcl::mcase))
                                                         (eq arg (cadr false-value))))
                                       (false-clauses (if false-case?
                                                          (cddr false-value)
                                                          `((t ,false-value))))
                                       (case-sym (if (and (sb-pcl::dnet-methods-p true-value)
                                                          (if false-case?
                                                              (eq (car false-value)
                                                                  'sb-pcl::mcase)
                                                              (sb-pcl::dnet-methods-p
                                                               false-value)))
                                                     'sb-pcl::mcase
                                                     'sb-pcl::scase))
                                       (type-sym `(,(cadr type))))
                                  `(,case-sym ,arg
                                              (,type-sym ,true-value)
                                              ,@false-clauses))
                                `(if ,(bind ((arg (elt required-arguments position)))
                                            (case (car type)
                                              (class (bind ((class (second type)))
                                                       (if (null (class-direct-subclasses class))
                                                           `(sb-pcl::class-eq-test ,arg ,class)
                                                           `(sb-pcl::class-test ,arg ,class))))
                                              (class-eq `(sb-pcl::class-eq-test ,arg ,(cadr type)))))
                                     ,true-value
                                     ,false-value))))
                        #'identity))
         effective-methods)
    (flet ((listify-table (table)
             (bind ((result (mapcar 'car (sort (bind (list)
                                                 (maphash (lambda (k v)
                                                            (push (cons k v)
                                                                  list))
                                                          table)
                                                 list)
                                               '<
                                               :key #'cdr))))
               result)))
      (setf effective-methods (listify-table effective-methods-table)))
    (unless effective-methods
      (sb-c:compiler-style-warn "No effective method found for ~S~%" gf))
    `(flet ,(mapcar (lambda (method-info)
                      (bind ((form (make-generic-method-lambda-form (car method-info)))
                             (arguments (second form)))
                        `(,(second method-info) ,arguments
                           (flet ((call-next-method ()
                                    (apply (first ,(second arguments)) ,(first arguments))))
                             ,@(cddr form)))))
                    methods-info)
       (macrolet ((sb-pcl::methods (methods)
                    (bind ((method (first methods))
                           (name (second (find method ',methods-info :key 'car)))
                           (arguments ',required-arguments))
                      (if (null method)
                          (if (not ',other-arguments?)
                              (list* 'no-applicable-method ',gf arguments)
                              (list* 'apply ''no-applicable-method ',gf (append arguments '(.rest.))))
                          `(,name ,',arguments-list ',(mapcar (lambda (method)
                                                                (second (find method ',methods-info :key 'car)))
                                                              (rest methods)))))))
         ,compiled-net))))

(def (function e) make-generic-function-lambda-form (function-name)
  (bind ((generic-function (when (ignore-errors (fboundp function-name))
                             (fdefinition function-name))))
    (when (typep generic-function 'standard-generic-function)
      (bind (((:values required-arguments other-arguments?) (split-function-lambda-list (sb-mop:generic-function-lambda-list generic-function)))
             (rest-argument (when other-arguments? '.rest.)))
        (with-unique-names (arguments-list)
          `(lambda (,@required-arguments ,@(when rest-argument `(&rest ,rest-argument)))
             (bind ((,arguments-list (list* ,@required-arguments ,rest-argument)))
               ,(make-generic-function-discriminating-form generic-function arguments-list))))))))
